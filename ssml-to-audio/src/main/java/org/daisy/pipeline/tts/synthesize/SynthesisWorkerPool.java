package org.daisy.pipeline.tts.synthesize;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;

import net.sf.saxon.s9api.QName;
import net.sf.saxon.s9api.XdmNode;

import org.daisy.pipeline.audio.AudioEncoder;
import org.daisy.pipeline.tts.TTSRegistry;
import org.daisy.pipeline.tts.TTSService;
import org.daisy.pipeline.tts.TTSService.SynthesisException;

public class SynthesisWorkerPool {

	public static class UndispatchableSection implements
	        Comparable<UndispatchableSection> {
		int size;
		List<XdmNode> sentences;
		TTSService synthesizer;

		void computeSize() {
			size = 0;
			for (XdmNode sentence : sentences) {
				size += sentence.toString().length(); //TODO: write finer/faster computation
			}
		}

		@Override
		public int compareTo(UndispatchableSection other) {
			return (other.size - size);
		}
	}

	private SynthesisWorkerThread[] mWorkers;
	private TTSService currentSynthesizer;
	private AudioEncoder mEncoder;
	private TTSRegistry mTTSRegistry;
	private IPipelineLogger mLogger;
	private List<UndispatchableSection> mSections;
	private UndispatchableSection mCurrentSection;
	private int mNrThreads;

	public SynthesisWorkerPool(int threadNumber, TTSRegistry registry,
	        AudioEncoder encoder, IPipelineLogger logger) {
		mNrThreads = threadNumber;
		mWorkers = new SynthesisWorkerThread[threadNumber];
		for (--threadNumber; threadNumber >= 0; --threadNumber)
			mWorkers[threadNumber] = new SynthesisWorkerThread();

		mTTSRegistry = registry;
		mEncoder = encoder;
		mLogger = logger;
	}

	public void initialize() {
		mSections = new ArrayList<UndispatchableSection>();
		mCurrentSection = null;
	}

	public void pushSSML(XdmNode ssml) {
		String engine = ssml.getAttributeValue(new QName("engine"));
		String lang = ssml.getAttributeValue(new QName(
		        "http://www.w3.org/XML/1998/namespace", "lang"));

		TTSService newSynth = mTTSRegistry.getTTS(engine, lang);

		if (newSynth != currentSynthesizer) {
			if (currentSynthesizer != null)
				endSection(); // the same thread might not be able to
				              // concatenate outputs generated by different TTS
			currentSynthesizer = newSynth;
		}

		if (mCurrentSection == null) {
			mCurrentSection = new UndispatchableSection();
			mSections.add(mCurrentSection);
			mCurrentSection.sentences = new ArrayList<XdmNode>();
			mCurrentSection.synthesizer = currentSynthesizer;
		}
		mCurrentSection.sentences.add(ssml);
	}

	public void endSection() {
		mCurrentSection = null;
	}

	public void synthesizeAndWait(List<SoundFragment> soundfragments)
	        throws SynthesisException {
		//pre-allocate resources for every TTS of every thread
		Set<TTSService> allTTS = new HashSet<TTSService>();
		for (UndispatchableSection section : mSections)
			allTTS.add(section.synthesizer);

		StringBuilder sb = new StringBuilder(
		        "start allocating the resources on " + mNrThreads
		                + " threads for the following TTS service(s):\n");
		for (TTSService tts : allTTS) {
			sb.append(" * " + tts.getName() + "-" + tts.getVersion() + "\n");
		}
		mLogger.printInfo(sb.toString());

		for (TTSService tts : allTTS)
			for (SynthesisWorkerThread worker : mWorkers)
				worker.allocateResourcesFor(tts);

		mLogger.printInfo("thread resources allocated.");

		//sort the 'undispatchable' sections according to their size in descending-order
		for (UndispatchableSection section : mSections)
			section.computeSize();
		Collections.sort(mSections);
		mLogger.printInfo("number of sections to synthesize: "
		        + mSections.size());

		//give SynthetisWorkerThread access to a synchronized queue of sections to synthesize
		ConcurrentLinkedQueue<UndispatchableSection> queue = new ConcurrentLinkedQueue<UndispatchableSection>(
		        mSections);
		for (SynthesisWorkerThread worker : mWorkers)
			worker.init(mEncoder, mLogger, soundfragments, queue);

		//perform the synthesis and encoding
		for (SynthesisWorkerThread worker : mWorkers)
			worker.start();

		// wait for the threads to finish
		for (SynthesisWorkerThread worker : mWorkers)
			try {
				worker.join();
			} catch (InterruptedException e) {
				mLogger.printInfo("error in synthesis thread: "
				        + e.getMessage());
			}

		mLogger.printInfo("synthesis workers finished");

		for (SynthesisWorkerThread worker : mWorkers)
			worker.releaseResources();

		mLogger.printInfo("synthesis resources released");
	}
}
