package org.daisy.pipeline.tts.synthesize;

import java.util.List;

import net.sf.saxon.s9api.QName;
import net.sf.saxon.s9api.XdmNode;

import org.daisy.pipeline.audio.AudioEncoder;
import org.daisy.pipeline.tts.TTSRegistry;
import org.daisy.pipeline.tts.TTSService;

/**
 * The SynthesisWorkerPool must be used as follow: 1. call initialize() 2. call
 * pushSSML() to push all the SSML fragments you want to encode 3. call
 * endSection() to force the encoder to write the next audio data to a new file.
 * 4. call synthesizeAndWait() to perform the synthesis.
 */
public class SynthesisWorkerPool {

	private SynthesisWorkerThread[] mWorkers;
	private int currentWorkingThread;
	private TTSService currentSynthesizer;
	private AudioEncoder mEncoder;
	private TTSRegistry mTTSRegistry;
	private IPipelineLogger mLogger;

	public SynthesisWorkerPool(int threadNumber, TTSRegistry registry,
	        AudioEncoder encoder, IPipelineLogger logger) {
		mWorkers = new SynthesisWorkerThread[threadNumber];
		for (--threadNumber; threadNumber >= 0; --threadNumber)
			mWorkers[threadNumber] = new SynthesisWorkerThread();

		mTTSRegistry = registry;
		mEncoder = encoder;
		mLogger = logger;
	}

	/**
	 * Initialize the workers with a given synthesizer and encoder.
	 * 
	 * @param soundfragments is the list of references to sound files (such as
	 *            mp3) produced by the combination of the synthesizer and the
	 *            encoder. Operations on this list must be thread-safe.
	 */
	public void initialize(List<SoundFragment> soundfragments) {
		for (SynthesisWorkerThread worker : mWorkers)
			worker.init(mEncoder, soundfragments, mLogger);

		currentWorkingThread = 0;
	}

	public void pushSSML(XdmNode ssml) {
		String engine = ssml.getAttributeValue(new QName("engine"));
		String lang = ssml.getAttributeValue(new QName(
		        "http://www.w3.org/XML/1998/namespace", "lang"));
		TTSService newSynth = mTTSRegistry.getTTS(engine, lang);

		if (newSynth != currentSynthesizer) {
			if (currentSynthesizer != null)
				endSection(); // the same thread might not be able to
				              // concatenate outputs generated by different TTS
			currentSynthesizer = newSynth;
		}

		mWorkers[currentWorkingThread].pushSSML(ssml, currentSynthesizer);
	}

	public void endSection() {
		mWorkers[currentWorkingThread].endSection();
		currentWorkingThread = (currentWorkingThread + 1) % mWorkers.length;
	}

	public void synthesizeAndWait() {
		for (SynthesisWorkerThread worker : mWorkers)
			worker.start();

		// wait for the threads to finish
		for (SynthesisWorkerThread worker : mWorkers)
			try {
				worker.join();
			} catch (InterruptedException e) {
				mLogger.printInfo("error in synthesis thread: "
				        + e.getMessage());
			}
	}

}
