package org.daisy.pipeline.tts.synthesize;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;

import net.sf.saxon.s9api.QName;
import net.sf.saxon.s9api.XdmNode;

import org.daisy.pipeline.audio.AudioEncoder;
import org.daisy.pipeline.tts.TTSRegistry;
import org.daisy.pipeline.tts.TTSService;
import org.daisy.pipeline.tts.TTSService.SynthesisException;
import org.daisy.pipeline.tts.TTSService.Voice;

public class SynthesisWorkerPool {

	static class Speakable {
		Speakable(Voice voice, XdmNode sentence) {
			this.voice = voice;
			this.sentence = sentence;
		}

		Voice voice;
		XdmNode sentence;
	}

	public static class UndispatchableSection implements Comparable<UndispatchableSection> {
		int size;
		int documentPosition;
		List<Speakable> speakables;
		TTSService synthesizer;
		Voice voice;

		void computeSize() {
			size = 0;
			for (Speakable speakable : speakables) {
				size += speakable.sentence.toString().length(); //TODO: write finer/faster computation
			}
		}

		@Override
		public int compareTo(UndispatchableSection other) {
			return (other.size - size);
		}
	}

	private SynthesisWorkerThread[] mWorkers;
	private TTSService currentSynthesizer;
	private AudioEncoder mEncoder;
	private TTSRegistry mTTSRegistry;
	private IPipelineLogger mLogger;
	private List<UndispatchableSection> mSections;
	private UndispatchableSection mCurrentSection;
	private int mNrThreads;

	public SynthesisWorkerPool(int threadNumber, TTSRegistry registry, AudioEncoder encoder,
	        IPipelineLogger logger) {
		mNrThreads = threadNumber;
		mWorkers = new SynthesisWorkerThread[threadNumber];
		for (--threadNumber; threadNumber >= 0; --threadNumber)
			mWorkers[threadNumber] = new SynthesisWorkerThread();

		mTTSRegistry = registry;
		mEncoder = encoder;
		mLogger = logger;
	}

	public void initialize() {
		mSections = new ArrayList<UndispatchableSection>();
		mCurrentSection = null;
	}

	/**
	 * The SSML is assumed to be pushed in document order.
	 * */
	public void pushSSML(XdmNode ssml) throws SynthesisException {
		String voiceVendor = ssml.getAttributeValue(new QName("voice-vendor"));
		String voiceName = ssml.getAttributeValue(new QName("voice-name"));
		String lang = ssml.getAttributeValue(new QName("http://www.w3.org/XML/1998/namespace",
		        "lang"));

		Voice voice = mTTSRegistry.findAvailableVoice(voiceVendor, voiceName, lang);
		if (voice == null) {
			throw new SynthesisException("Could not find any installed voice matching "
			        + new Voice(voiceVendor, voiceName) + " or providing the language '"
			        + lang + "'");
		}
		TTSService newSynth = mTTSRegistry.getTTS(voice);

		if (newSynth != currentSynthesizer) {
			if (currentSynthesizer != null)
				endSection(); // the same thread might not be able to
				              // concatenate outputs generated by different TTS
			currentSynthesizer = newSynth;
		}

		if (mCurrentSection == null) {
			mCurrentSection = new UndispatchableSection();
			mSections.add(mCurrentSection);
			mCurrentSection.speakables = new ArrayList<Speakable>();
			mCurrentSection.synthesizer = currentSynthesizer;
			mCurrentSection.documentPosition = mSections.size();
		}
		mCurrentSection.speakables.add(new Speakable(voice, ssml));
	}

	public void endSection() {
		mCurrentSection = null;
	}

	public void synthesizeAndWait(List<SoundFragment> soundfragments)
	        throws SynthesisException {

		//sort the 'undispatchable' sections according to their size in descending-order
		for (UndispatchableSection section : mSections)
			section.computeSize();
		Collections.sort(mSections);
		mLogger.printInfo("number of sections to synthesize: " + mSections.size());

		//give SynthetisWorkerThread access to a synchronized queue of sections to synthesize
		ConcurrentLinkedQueue<UndispatchableSection> queue = new ConcurrentLinkedQueue<UndispatchableSection>(
		        mSections);
		for (SynthesisWorkerThread worker : mWorkers)
			worker.init(mEncoder, mLogger, soundfragments, queue);

		//pre-allocate resources for every TTS of every thread
		Set<TTSService> allTTS = new HashSet<TTSService>();
		for (UndispatchableSection section : mSections)
			allTTS.add(section.synthesizer);

		StringBuilder sb = new StringBuilder("start allocating the resources on " + mNrThreads
		        + " threads for the following TTS service(s):");
		for (TTSService tts : allTTS) {
			sb.append("\n * " + tts.getName() + "-" + tts.getVersion());
		}
		mLogger.printInfo(sb.toString());

		for (TTSService tts : allTTS)
			tts.beforeAllocatingResources();

		for (TTSService tts : allTTS)
			for (SynthesisWorkerThread worker : mWorkers)
				worker.allocateResourcesFor(tts);

		for (TTSService tts : allTTS)
			tts.afterAllocatingResources();

		mLogger.printInfo("thread resources allocated.");

		//perform the synthesis and encoding
		for (SynthesisWorkerThread worker : mWorkers)
			worker.start();

		// wait for the threads to finish
		for (SynthesisWorkerThread worker : mWorkers)
			try {
				worker.join();
			} catch (InterruptedException e) {
				mLogger.printInfo("error in synthesis thread: " + e.getMessage());
			}

		mLogger.printInfo("synthesis workers finished");

		for (TTSService tts : allTTS)
			tts.beforeReleasingResources();

		for (SynthesisWorkerThread worker : mWorkers)
			worker.releaseResources();

		for (TTSService tts : allTTS)
			tts.afterReleasingResources();

		mLogger.printInfo("synthesis resources released");
	}
}
